paradis htutugrazacat fri mar  bloody spc          try stumble inner secret nasty chip antitrack exclusively famidev development group chapter      fact spc stupid sound chip worst handling seen lifetime chip co processor quite large instruction set contrary amiga copper small one kb ram memory use atleast kb program data supposed run chip must moved spc ram small loop poke byte spc assembler program eg sample data four memory location chance communicate spc four memory location different meaning read write read lda get data memory loc f sound chip poweron spc jump much like main processor small rom area resides ffc ffff inside spc chip really follows black box principle eh  program ffc waiting get data right format input port f  c eg point view main program therefore follow spc condition poke program data spc  special order transmission completed also transmitted start address spc code spc start execute program           question q move program data spc format use first spc datacode moved rom extra ram eg f dont ask ram probably doesnt existing routine send data spc something like datacode group call  chunk  valid chunk look like first word number byte transmit spc  sec word start address move data spc one chunk byte  datacode  many chunk want last chunk must like first word second word start address code q right mean transmitted code data spc code take control might encounter problem spc program communicate outer world c main program want change sound background melody shall always play two voice extra two voice used sound effect whenever player sprite eg pick object sure point code look memory location ffff accessible outside  easiest way would soon f f change jump boot rom ffc spc executing receive routine probably send another spc chunk new sound code spc  q help complete new tune played doesnt help melody using two voice shall still remain  thats true best approach send command byte spc spc code check f f constantly react   command byte like could mean sound play tune f play tune f play jingle fx ff jump ffc receive rom routine q another approach yes probably know important address spc reside inside ram zeropage address register usage volume left volume right pitch low pitch high total bit pitch height srcn designates source number  adsr adsr gain envelope freely designated code envx present val envelope dsp rewrite valx present wave height val  approach would move sample data andor lot small chunk data target address zeropage starting address eg ffc small chunk would access zeropage address eg volume etc thus result tone done every frame might end music player quite similar c styled one q anyway format exactly move data spc following source code let explain bit start dig already mentioned general  chunk  format loop following move ram destination address  akku bit move either depends byte data spc first time first chunk transmit move constant cc loop poke byte want transmitted word higher  bit accuword contain number byte already moved eg start cmp number byte already moved lower bit number wait equal loop next chunk header repeated cc moved  nn  lobyte number byte moved    used example move word access move move cc move  gg   gg  first real codedata byte spc wait till move hh  hh  second byte code data spc wait till move ii  ii  rd byte data spc  wait till let say  ii  last byte add carry number many byte moved spc push onto stack fetch next header poke target ram address word poke depending many byte send poke number byte sent last chunk think got scheme pretty much right time please someone going donate homebrewed spc disassemblers oh pretty please hate silent snes source code follows reassembled panbaseline demo  xmas wish                                         entry code start sep x set bit length lda ff ff audiow write sta rep x bit length ldx fff ldbb lda x move rom music data ram f sta f x lda x move rom music data ram f sta f x dex bpl ldbb lda screen probably important sta lda fdfeff point data sta fd ram f lda sta fe lda f sta ff stz disable nmi timer hv count sei disable irq jsr ldbcd unknown sub routine labeled  restart  panatx sep regs bit ldbb lda wait reply sound chip bne ldbb lda e audiow sta lda ff send data sound chip sta ffe could address within sound chip rom ffc ffff rom mask   lda send data sound chip sta lda send data sound chip sta ldba lda wait reply sound chip cmp fuck protocol  bne ldba ldbab lda wait reply soundchip cmp bne ldbab lda aha  move sound chip sta probably sound number selector lda sta send data sound chip ldbbd lda wait sound chip accepted data cmp bne ldbbd ldbc lda wait reply cmp bne ldbc cli rts ldbcd php labeled  restart  panatx jsr ldbd plp lda audiow sta rts ldbd php rep x bit regs ldy needed first time lda fd pointer ram lda bbaa ldbe cmp wait sound chip  bne ldbe sep akku bit lda cc bra ldc oh well another mystery jump overflow set eg data move ldbec lda fd get data ram pointer iny accumulator get  xx  xba  xx  byte fd first data byte lda resides bit  accu bra ldbff bit number byte already sent ldbf xba accu  nn  old data last loop lda fd accu  nnxx  xx newest data byte iny spc xba accu  xxnn  ldbf cmp wait sound chip reply  nn  bne ldbf inc increment number byte sent  accu  xxnn  newest val nn nn ldbff rep akku bit sta poke  xxnn  soundchip xx actual data sep akku bit nn bit cutted number byte dex already sent bne ldbf many time xreg say  ldc cmp byte  nn  replied spc data bne ldc received correctly ldce adc compare accu fb adc add coz carry always set cmp attention beq ldce accu fb accu ldc pha push value accu stack beginning cc rep accu bit lda fd get ram data byte iny point next word iny tax x number byte transmit lda fd get ram data iny iny sta audiow possibly dest area spc sep accu bit cpx set carry first ram data lda rol sta ram data poke   reg otherw adc f set overflow flag x nice trick pla sta cc first case nn later case ldc cmp wait snd chip reply bne ldc bvs ldbec data spc ram move r supposed belong plp rts pla sta shit never jumped ldcf cmp bne ldcf bvs ldbf plp rts also let look f first byte f f b e cd cf bd e af c f fb b e number byte transmit destination inside spc  point really need spc disassembler   okay well first source incompetent sure thing think could solve lot question meanwhile 