chapter description error message  unknown mnemonic assemblylanguage line start builtin instruction mnemonic mov add circumstance line start nonbuiltin symbol symbol macro name int equate symbol defined indicated limited set following symbol colon equ db dw etc line started nonbuiltin symbol fall category might misspelled instruction mnemonic misspelled following word  jump  destination operand conditional jump must label within byte end instruction precisely   next instruction   start conditional jump error reported three possible place conditional jump operand byte jump operand label eg tried indirect conditional jump variable nt allowed label definition case use editor search backwards reference label one earliest conditional jump found far away ret retf iret instruction use editor search backwards flavor ret used operand conditional jump conditional return feature earliest jump satisfied previous ret far away usually correct error rearranging code better breaking intervening code subroutine desperate replace  jcond   cond jmp   bxbp sidi allowed instruction set support combination indexing register indicated error message previous version error reported illegal operand combination attempted change case error ever find otherwise let know  bad character number number number start decimal digit illegal symbol begin digit eg myvar coded something start decimal digit correct format numeric constant see chapter detailed description format integer floating constant   operand allowed error reported usually mean provided something mnemonic instruction operand eg pushf stosb stc fldpi clts also called context assembler expects nothing line eg name single name following something following word end  symbol required reported numerous situation requires sort symbol either builtin assembler mnemonic symbol define possible number punctuation mark legal context already checked instead symbol punctuation mark outofcontext number seen context error occur include start line character hex c greater following start line symbol define code data operand following directive expected name public extrn group segment   denoting locallabel forward reference  local symbol required reported something generic local label letter followed one digit follows   mark denotes locallabel forward reference meant  greater  use gt operator instead  many operand reported instruction directive requiring limited number operand limit exceeded since operand separated comma many comma  possibly extra comma mnemonic first operand end operand  constant required reported instruction directive enter ret radix etc requiring operand immediate constant number expression operator shl etc whose operand must constant case limited number form constant acceptable assembler already checked found possibility  operand required  reported instruction requiring two operand provided operand one operand might left comma separating operand  constantlabel allowed reported given constant number place nt allowed  usually destination operand instruction first operand mov add meant operand memory location constant offset must convert type enclosing operand bracket appending sizespecifier b w q number  segment register allowed reported used segment register instruction nt allowed instruction allowing segment register operand mov push pop ca nt example add segment register want anything segment register value mov general register perform operation mov result back segment register  byteword combination allowed reported twobyte instruction one operand bytesized wordsized instruction bytesized destination immediate source whose value bytesized high byte ff one operand memory variable wrong size either change declaration variable db dw vice versa override size variable instruction appending  b   w  memory operand  bad operand combination reported attempt add combine term operand expression allow combination example would dt bx constant added floating point number also reported two operand mismatched size mismatch something byte v word example mov al  bad subtraction operand  reported attempt subtract term operand expression allow subtraction righthand side subtraction missing righthand side subtraction nonforwardreferenced constant left side almost anything otherwise operand must match eg label relocatable segment must segment case answer absolute constant namely size block memory two label  definition conflict forward reference error occurs assembler previously guessed type forwardreferenced symbol order determine kind instruction generate guess turned wrong error reported time symbol defined example see mov ax foo assume foo immediate value error reported foo turn word variable foo dw need search backwards error message reference foo specify type intend used mov ax foo w really intend load offset foo memory content code mov ax offset foo make error message go away  divide overflow reported righthand side division mod operation zero result division large k number still large  type required reported two operand relational operator eq ne gt ge lt le different type operand relational operator ought absolute integer constant label segment  c destination allowed reported attempt specify c destination first operand mov operand pop acceptable way load c via far jmp call retf iret instruction mov pop form nt make much sense outlawed intel  left operand allowed reported lefthand side expression operator expects single operand right operator bit offset type low high short long int mnemonic int considered operator eg msdos equ int example would get error expression  bad single operand  reported operand inappropriate instruction inc dec push pop neg mul imul div idiv take single operand look instruction chart chapter determine proper operand form allowed  bad dup usage reported dup construct occurs context eg instruction operand instead data initialization total number byte generated would push output pointer beyond k improper syntax dup see chapter description correct dup usage  number large reported numeric constant large assembler store operand buffer  limit integer  decimal error also given exponent part floating point constant greater magnitude  segment end required reported line beginning one two keywords code data continue one keywords segment end meant code data symbol define change name something else like code data  bad calljmp operand reported operand call jump instruction taken jump destination occurs operand missing size inappropriate address pointer byte quadword tenbyte error also occurs operand constant number assembling obj format obj format anything jumped within segment must specified label within segment  memory doubleword required reported second operand lds le bound instruction wrong type operand doubleword memory quantity accept word memory variable memory variable unspecified size  bad inout operand reported operand correct form see chapter limited set form instruction one operand must al ax must dx constant  type required  reported symbol given extrn list followed one type name b w q f near ab verbose synonym byte word dword qword tbyte also acceptable  bad rotateshift operand reported count second operand rotate shift instruction appropriate either name cl constant le instruction requiring rol ror rcl rcr shl shr sal sar necspecific instruction setbit testbit clrbit notbit  bytesized constant required reported context bytesized absolute constant acceptable context operand bit int operator expression required operand int call instruction optional operand aam aad instruction  instruction data segment allowed limited number directive allowed struc data segment error reported instruction disallowed directive seen one restricted environment possibly neglected provide end directive returning normal assembly struc directive allowed db dw dd dq dt another struc end equ segment group macro label even org data segment allows directive plus proc endp data code  bad string reported start quoted string provide closing quote line might left might intended code string accidentally inserted single doublequote mark line might intended string containing endofline nt allowed must instead close string code hex byte da represent endofline  bad data operand reported inappropriate operand seen data initialization db dw dd dq dt directive example indexed quantity bx nonbyte quantity db floating point constant db dw  index bracket required  reported name register given additioncombination operation register enclosed square bracket register may added presented indexing register example nt code bx code bx  bad character reported punctuation mark nonstandard character seen expected character causing error beginning line digit mark   illegal mark start line cause error symbol required character causing error elsewhere ie within operand character except letter digit mark   string allowed reported string character seen outside place string allowed db directive macro operand relocatable segment directive one twocharacter string treated simple numeric constant longer string require special handling allowed place mentioned  misplaced builtin symbol symbol error message builtin symbol place nt belong example mnemonic mov occurring operand symbol nt mnemonic lt occurring start line thought could define symbol left message use wrong need change symbol something else test test example like know builtin meaning symbol look chapter  segment combination allowed reported attempt add combine segment group name another quantity currently doesnt allow  bad index register reported attempt use register si di bx bp indexing register architecture allows place inside bracket address memory  conflicting multiple definition allowed  reported define symbol two place program definition nt often simply forgotten already symbol somewhere name need change name one two symbol defined allows reuse symbol generic local label letter followed one digit defined instead equ also allows redefinition symbol exactly value eg esc equ b two place program see section  duplicate definition  chapter detailed discussion feature  end segment error occurs assembling obj file see end outermost level segment  end preceded matching segment directive need look segment end directive get match properly  bad operand reported followed one flagmnemonics eg e z nc ae etc follow  j  conditional jump instruction likely line conditional assembly line intended another assembler conditional assembly line begin hash sign change else endif else endif may also need change condition following foo equ becomes foo ifdef foo becomes simply foo expression must replaced two line c equ expression followed c see chapter detail syntax conditional assembly see chapter way us nt hash sign  parenthesisbracket mismatch reported lack balance parenthesis bracket operand expression  many leftsides many rightsides bracket interleaved illegally likely left opening closing parenthesisbracket complicated expression spurious extra crept code  bad forward reference combination reported try use forward reference expression complicated handle add subtract constant forwardreferenced symbol ca nt subtract forwardreferenced symbol anything ca nt add two forward reference together typically get around restriction forward reference expression moving expression equ directive point symbol defined making forward reference equated symbol represents evaluated expression  error also reported situation involving relocatable symbol obj mode  symbol forward reference sense resolved link time  byte word reported memory operand unspecified size need know whether operand bytesized wordsized order generate correct instruction form need append b w operand specify size want example youve coded inc bx need decide inc b bx inc w bx coded add foo foo forward reference need specify add foo b add foo w  bad construct reported within macro definition seen followed one allowed macro parameter construct described chapter even quoted string hash sign must literalized via taken asis mistakenly provide macroloop variable w x z outside loop defining variable error detected macro expanded even though error macro definition error also reported occurs beginning line followed elseif else endif conditional assembly parameter builtin mnemonic eg mov see chapter correct usage hash sign macro conditional assembly  endif required reported without corresponding endif end file end macro expansion assembled macro expansion message appears end file need search backwards ifs find unclosed block  em required end macro reported macro without end end macro given em likely file written another assembler need convert macro definition need change endm directive em also need eliminate named parameter macro line replace occurrence named parameter etc concatenation operator dropped see chapter full description macro syntax  end delimiter comment required  reported portion code skipped comment directive run end file without closing delimiter found need search backwards end file find comment directive figure intend directive end duplicate delimiter first nonblank following comment endpoint see chapter full description comment directive  reg mem required reported improper combination operand mov xchg general arithmetic instruction add sub cmp xor etc often attempted provide two memory operand mov var var add var var one operand must register effect memorytomemory operation using register twoinstruction sequence example mov ax var followed add var ax convenience let code sequence single line add var ax var nt wish clobber content register operand wordsized may push source operand pop destination operand push var followed pop var  segment override allowed compatibility assembler allows segment override operator c d e s within expression instruction operand override informs assembler named segment register used memory reference assembler might generate segment override opcode byte error reported segment override operator occurs context special threeoperand form mov arithmetic instruction within data segment struc equ directive might encounter last case porting program written another assembler might provide explicit override wherever equated symbol used possible though override provided satisfy assembler segment checking mechanism override generated case eliminate override operator  byte operand required reported operand one necspecific instruction stobits lodbits rol ror wrong type stobits lodbits require first operand bytesized register second operand either bytesized register immediate constant rol ror require operand bytesized register  word register required  reported first operand instruction lds le lea bound imul lar lsl wordsized general register ax bx cx dx si di bp sp  floatingpoint chip required reported attempt assemble program floating point constant floating point expression floating point chip computer system us assemble constant arithmetic time buy chip install empty socket  bad floatingpoint operand reported operand floating point instruction correct type see chapter correct form instruction coding possibility error memory operand unspecified size size compatible instruction integer instruction fixxx require w operand floating arithmetic instruction require q operand tried specify register instead memory operand tried special fld constant form obj mode sorry support com mode mainly specified two register number neither tried one disallowed form fcom fcomp  constant  required reported constant number operand instruction supposed represent stack number right value ie integer range  memory operand required reported operand floatingpoint protectedmode instruction must memory operand operand provided nt one see chapter floating protected correct syntax instruction coding  segment struc name allowed  error occurs often attempting assemble com program file intended exe program com format allow refer value named segment make far pointer label within program either use option produce obj file simply eliminate statement intended set segment register  com program started segment register already pointing value error also reported provide name structure name int equate place register memory operand expected  word operand required reported something wordsized operand provided one instruction arpl sldt lldt str ltr verr verw smsw lmsw  circular definition allowed reported chain macro call reference undefined symbol reach depth assumes infinite loop example foo equ foo baz macro containing uncontrolled call baz within  overlapping local allowed recall chapter use local label symbol twice must distinguish reference symbol prepending symbol name reference forward reference get error followed forward reference another reference without next incaration symbol defined danger intended reference previous incarnation nt allow example l first incarnation l jnz l reference second incarnation jmp l error  incarnation referring l second incarnation l intended jmp second l prepend l like jnz intended jmp first l must change one two label name range nt overlap  org required first data segment  previous version allowed default starting offset data segment hope future change default offset immediately following program com file transition outlawing orgless data segment intention start offset must state explicitly org following first data segment directive program  object overflow reported assembler run room output objectcode segment also hold record used resolve forward reference happen object output nears object capacity k full amount memory k available assembler limited amount memory increase memory available buying another board fewer memoryresident program installed run assembling obj file break program smaller assembled module conceivable error could result session using patchmemory mode type extremely complicated program case type program text file instead use assemble text file  undefined symbol allowed error occur debugging session type immediateexecution assembly language line containing symbol table typically mistyping part allows add symbol table patchmemory mode reached pressing f key  symbol table overflow reported symbol table run space unlikely ever run error since capacity thousand symbol need reduce number symbol program one way replace placemarker symbol local label limited range like l  l see chapter description local label facility 