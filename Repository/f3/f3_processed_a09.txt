chapter directive segment following discussion applies assembling com see next chapter discussion segmentation obj file view computer memory space two part first part program whose content object byte generated assembly source call area code segment second part data area whose content generated program start running call area data segment please note well difference code data segment whether content generated program assembler name code data suggest program code placed code segment data structure go data segment mostly true exception example many data structure whose content determined assembler pointer table array predefined constant etc table assembled code segment general want begin program directive data segment followed org statement giving address start data area list program variable uninitialized data structure using directive db dw struc allocate space starting address given org statement generate object byte space data segment declaration provide code segment directive program start location standard give org giving address start program follow program together assemblergenerated data structure short program illustrating suggested usage follows data segment org answerbyte db callcount dw code segment jmp main trantable db  main mov bx trantable xlatb mov answerbyte al inc callcount ret  allows intersperse code segment data segment throughout program general best put data segment declaration top program avoid problem forward referencing code end data end statement compatibility intelibm assembler provides code end data end statement code end statement ignored assume nested code segment inside data segment data end statement equivalent code segment statement org directive syntax org address org move output pointer location counter assembly currently taking place within current segment value operand absolute constant expression evaluating absolute nonforwardreferenced constant org often used data segment control location data area within segment example program fit entirely k provide org directive first line within data segment top program location given org location sure beyond end program sure program go beyond k hex program look like data segment org data go beyond end program data segment variable buffer declaration go data end program go  special side effect org used code segment begin code segment org know assembling com program instead assembling code segment used context example programming rom assembling procedure older version turbo pascal output file start com file default extension output file bin com example general issue org within code segment would lower value output pointer thereby put danger losing part assembled program reassemble space already assembled clobber previouslyassembled code also aware size output program file determined value code segment output pointer program stop org lower value end program output program file truncated lowervalue address almost program producing com file need org directive code segment implied org start program start coding instruction assembler put right place even directive syntax even even directive coerces current output pointer even value data segment struc adding pointer pointer odd nothing pointer already even code segment output nop pointer odd even often used data segment sequence dw directive bit machine family fetch word quickly aligned onto even address even directive insures program faster access dw follow speed improvement seen bit machine notably original ibmpc data allocation using db dw dd dq dt computer family support three fundamental data type byte word dword byte eight bit word bit byte doubleword bit byte addition floating point processor manipulates byte quantity call qwords byte quantity call tbytes data allocation statement used specify byte word doublewords qwords tbytes program use data syntax data allocation statement follows  optional varname db list value optional varname dw list value optional varname dd list value optional varname dq list value optional varname dt list value variable name present cause name entered symbol table memory variable type byte db word dw dword dd qword dq tbyte dt variable name colon unless wish name label instruction referring interpret label constant pointer memory location content db statement used reserve byte storage dw used reserve word list value right db dw serf two purpose specifies many byte word allocated statement well initial value list value may contain single value one separated comma list even missing meaning wish define byte word variable location next variable data initialization data segment value given ignored except place marker reserve appropriate number unit storage use   com mode synonym zero recommended context emphasize lack actual memory initialization assembling obj file initialization cause break segment unless embedded nested dup containing non term case synonym zero special value used data initialization dup construct allows allocation andor initialization block data expression n dup x equivalent list x repeated n time  x  either single value list value another dup construct nested inside first one nested dup construct need surrounded parenthesis assembler earlier version require parenthesis around right operand dup even simple one requirement removed simple operand current example data initialization statement without dup construct code segment dw allocate one word init db  allocate three byte init  db dup equivalent db  dw dup  dup equivalent dw   data segment xx dw define word variable xx yylow db init value yylow low byte word var yy yy dw xarray db dup xarray byte array dreal dq double precision floating variable exreal dt extended precision floating variable character string value may used initialize consecutive byte db statement character represented ascii code character stored order appear string first character assigned lowestaddressed byte db statement follows five byte initialized ascii representation character string hello db hello note except string comparison described previous chapter db directive place program string length greater may occur context including dw string treated constant number representing ascii value string example cmp al instruction comparing al register ascii value atsign note character string constant like constant byte reversed thus db ab produce hex followed hex similar looking dw ab revers byte hex followed hex compatibility accepts double quote well single quote string db directive dd directive used initialize bit doubleword pointer location arbitrary segment memory space value pointer given two number separated colon segment register value appears left colon offset appears right colon keeping reversedbytes nature memory storage family offset come first memory example statement dd  appearing code segment cause hex byte generated long pointer segment offset dd dq dt also used initialize large integer floating point number example dd half million big instruction dd  single precision floating point number dq  number double precision format dt  number extended precision format  struc directive struc directive used define template data addressed one base andor index register syntax struc follows optional strucname struc optional effective address optional structure name given beginning line appear subsequent expression program operator type applied yield number byte structure template struc directive cause assembler enter mode similar data segment assembly within structure declares symbol element structure using location counter start address following struc address given assembly start location option available data segment address include one base register bx bp andor one index register si di register part implicit declaration structure element offset value increasing number byte allocated structure line example line struc bp template start bp db dup byte advance u bp lsize db byte advance u bp lprot db end struc given defines variable lsize equivalent b bp lprot equivalent b bp issue instruction mov al lsize automatically generates correct indexing mode entered struc terminated end directive return assembler whatever segment code data struc location counter restored value within segment struc declared forward reference allows name variety program element forward referenced mean may use symbol one statement define later another statement example jnz target target add ax  example conditional jump made target label farther code jnz target seen target undefined forward reference earlier version much restricted kind forward reference allowed restriction eased convenience well compatibility assembler particular may make forward reference variable name need see enough information type operand generate correct instruction example mov foo al cause correctly deduce foo byte variable even code subsequent mov foo remember foo assumed byte variable code mov foo first wo nt know whether issue byte word mov instruction thus issue error message specify type mov foo b general compatibility assembler improved dramatically forward reference program need sprinkle b w reference rewarded many case word form longer byte form assembler wind inserting wasted nop program wind tighter code using forward reference expression allows add subtract constant number forward reference symbol append indexing register forward reference symbol cover vast majority expression formerly disallowed remaining complicated expression trick use work way around almost case might run forward reference restriction trick move expression evaluation program longer contains forward reference forward reference evaluation answer example suppose wish advance e segment register point immediately beyond program progsize number byte program add progsize  program segment register value value known assembly time nt known end program following mov ax c fetch program segment value add ax segsize use simple forward reference mov e ax e loaded desired end program evaluate expression progsize equ segsize equ progsize   equ directive syntax symbolname equ expression symbolname equ builtinsymbol symbolname equ int n expression field may specify operand type could appear operand instruction simple example suppose writing program manipulates table containing name want refer maximum number name throughout source file course use number refer maximum time mov cx approach suffers two weakness first mean lot thing absence comment obvious particular use refers maximum number name secondly extend table allow name locate change suppose instead define symbol represent maximum number name following statement maxnames equ use symbol maxnames instead number example mov cx maxnames obvious referring maximum number name table also decide extend table need change equ directive every reference maxnames reflect change could also take advantage strong typing changing maxnames variable maxnames db even indexed quantity maxnames equ bx language strongly typed instruction loading maxnames cx register remains exactly case simply mov cx maxnames  equates builtin symbol allows define synonym assembler reserved symbol equating alternate name choosing symbol example suppose coding source module incorporated several different program program certain variable exist code segment others exist stack segment want address variable common source module nt know segment override use solution declare synonym q segment register q defined program codesegment program q equ c top stacksegment program q equ s source module use q override c s code would example q mov al varname nil prefix provides mnemonic nil generates code nil used prefix another instruction effect instruction appear line nil provided extend example previous section cover possibility override source module go program fit k segment register value code q equ nil top program interrupt equates allows equate name int instruction specific interrupt number example place trap equ int top program use name trap synonym int debugger trap duplicate definition contains unique feature duplicate definition already discussed local symbol redefined different value without restriction local symbol symbol redefined however symbol defined long symbol defined value type definition feature two us first eas modular program development example two independentlydeveloped source file use symbol esc stand ascii code escape contain declaration esc equ b problem combined program  second use feature assertion checking deliberate redeclaration symbol name assertion value symbol changed want assembler issue error message changed example suppose declared table option data segment another table initial value option code segment come back month later add option table want reminded update table way declare table follows data segment option optcount equ option optcount size table code segment optinits optcount equ optinits second optcount better directive syntax symbolname expression symbolname builtinsymbol symbolname int n equal sign directive provided compatibility assembler identical equ directive one exception first time symbol appears program directive symbol taken local symbol redefined value like generic local symbol letter followed digit support try redefine equ symbol different value get error message facility often used define  assembler variable  change value assembly progress proc directive syntax name proc near name proc far name proc proc directive provided compatibility intelibm assembler nt like proc recommend use even programming assembler  idea behind proc give assembler mechanism whereby decide kind ret instruction providing specify near proc directive assembler generate near segment return see ret specify far proc directive assembler generate far retf return cause ip c popped stack simply leave well enough alone never code proc program ret mean near return throughout program reason nt like proc yet another attempt assembler thing  behind back  go reason programming assembly language first place complete control code generated source program lead nothing trouble confusion another problem proc verbosity replaces simple colon given right label defines creates visual clutter program make program harder read provides explicit retf mnemonic nt need use proc distinguish near far return instruction use ret near return retf far return even programming assembler need code far return recommend create retf macro would single line db cbh stay away procs entirely endp directive syntax name endp action take see endp directive return assembler sane default state ret near return note mean support nested procs anything innermost proc far attribute im sorry blunt anybody would subject program level syntactic clutter rock head label directive syntax name label near name label far name label byte name label word label another directive provided compatibility intelibm assembler provides le verbose way specifying label form except label far  label defines  name  type given value equal current output pointer thus label near synonymous simple colon following name label byte label word synonymous db dw respectively operand label far unique functionality found assembler identifies  name  procedure called outside program code segment procedure retfs instead rets furthermore provided following feature unique call procedure within program generate push c instruction followed near call procedure assembler generate far call functional effect far call consumes program space take time execute warning use call feature forward reference label far definition must precede call unavoidable since assembler must assume call undefined symbol take program byte assembler issue error situation 