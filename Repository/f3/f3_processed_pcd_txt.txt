appear proceeding computer game developer conference practical collision detection lecture jonathan blow jon boltactioncom http wwwboltactioncom  target audience  programmer realtime application intend implement sophisticated collision detection scheme  abstract  modern game require form collision detection paper present basic brute force method collision detection polyhedron successively refining technique left system run quickly implementation examined game engine handle player hundred object realtime  modus operandi  past year experimenting method collision detection use game goal paper communicate experience gained exposition  practice experience  paper present new work plant new condominium tract amid burgeoning field computer science hope merely provide observation idea useful others exploring subject idea presented many would evident anyone sat experimented collision detection time main goal save time paper constructed form match evolution collision detection system time first section begin slowly taking small step foundation firmly established detail history progress highlighting key discovery finally speed advanced concept leave jaded summary current state collision detection research  want  wanted make game  good collision detection  didnt take much time clarify precisely meant knew wanted object shape arbitrary polyhedron knew nt want grossly inaccurate collision result never wanted see object bounce empty space neither want see interpenetrate  first try  two object sticking closed polyhedron least one face one object penetrating least one face object detect case soon occurs  fix  situation moving object slightly longer penetrate done therefore decided logic governing object motion would proceed loop like game running foreach entity world update entity update entity entityoldposition entitycurrentposition modify entitycurrentposition based entityvelocity factor colliding entity entitycurrentposition entityoldposition colliding currententity bool foreach entity world entity currententity entitiescollide currententity entity return true return false entitiescollide e e bool foreach polygon p e foreach polygon p e polygonsintersect p p return true return false defined polygonsintersect description determine intersection two polygon found easier faster determine intersection convex polygon nonconvex one one may wish compose one model convex polygon many good reason graphic object collided chose move back starting position  safe  spot object moment ago probably still safe one alternative search space find new position object icky complication method chose example object moved back starting point must make sure really still safe object moved space meantime must move offending object back starting position worse happen revert every object world starting point part though pseudocode illustrates extremely basic extremely simple extremely slow way collision detection slow two object composed polygon collide loop body entitiescollide executed lot  time case finding whether two polygon intersect fastest operation known man currentday computer  time far instantaneous  time pair object may collide updating world many time per second becomes impossible dreadfully slow work exception talk later something work bad starting point  first filter  one way speed slow algorithm install  filter  keep slow part getting run nt need come easy answer using inexpensive technique immediately put place two simple filter experienced programmer would take given segregation good divide world regular grid partition object smaller group goal reducing number entityentity comparison system need make every time move object compute square grid overlap engine chose twodimensional grid although true world game played landscape expect many object piled top b bounding sphere polyhedronpolyhedron check look distance center two object sum two object radius object possibly interpenetrate speed slightly check distance squared versus sum radius squared avoids costly square root operation c prefer jersey actually originally third filter ran bounding sphere test looked manhattan distance object center really worth bother almost never saved execution time worth worrying deleted  filling gap  code discussed far test interpenetration might adequate never seen realtime object simulator movement nt discrete say motion occurs teleporting object place place illusion smooth motion arises distance object  jump  small faster object moving must jump fixed timestep object jump far enough one update could  miss  another object appearing fly right part one object could miss part another causing strange thing happen quick fix create  speedbox  around object speedbox bounding box enclosed full volume space object might pas one update testing collision would use speedboxs shape instead object actual shape violated original concern collision accurate waved hand said since object moving quickly nobody would see going anyway see game cool wimp like time want drastic theoretically sound alternative know represent shape mathematically function initial space occupancy velocity time solve huge set simultaneous equation determine collision expect approach computationally feasible time millennium divisiveness good ancient fact two convex polyhedron intersect one always find dividing plane rab exploiting fact seemed like good idea nt want limit object convex polyhedron express composed still true object mostly convex usually find dividing plane illustrated figure  wrote another filter called  plane divide entity  would heuristically try find dividing plane two object saw good point built stack  easy  tocompute filter would happen final collision detection became known  hard case  hard case speak still hard though filter helpful case failed apply two object got close way left easilyfound dividing plane game slowed unacceptably knew bsp tree cracked open reference began writing new hardcase code attempt explain bsp tree fully paper instead refer reader chin fv wade provide brief explanation sake context bsp tree consist hierarchy plane plane divide region space two halfspaces use describe solid object adopting convention separating plane leaf node describes portion object surface one plane halfspaces represents inside object represents space outside binary tree organization n node often allow search operation complete log n time collision detection trying perform fundamentally search intuitively use bsp tree well testing two object intersection able handle  hard case  collision test something like log n time n typical number polygon contained entity employ bsp tree speed collision detection using spatialpartitioning property reject polygon early detecting collision two entity b know lie entirely one side plane p cut b need test part b side plane sense sophisticated version plane divide entity test dividing plane eliminates part object rather whole thing bsp tree provide u myriad plane recurse bsp tree b finding whether bounding sphere intersects separating plane cheap operation ignore many polygon b chance colliding polygon b pass filter call procedure compare every polygon sample c source code presented struct polyhedron list face  polygon contained object point center  center object float radius  radius bounding sphere bspnode bsptree  bsp tree representing object enum flagvalue touchesposhalfspace x touchesneghalfspace x sliced x  touch halfspaces struct bspnode float b c  coefficient plane equation ax cz list polygon  polygon coplanar said plane bspnode positive negative  content halfspace bool objecthitsworld bspnode node polyhedron solid node  null return false int status classify node solid center solid radius status  sliced testsolidagainstpolygons node polygon solid return true status touchesneghalfspace objecthitsworld node negative solid return true status touchesposhalfspace objecthitsworld node positive solid return true return false int classify bspnode node point center float radius float distance centerx node centery node b centerz node c node int status distance radius  status  touchesneghalfspace distance radius  status  touchesposhalfspace return status bool testsolidagainstpolygons list polygon polyhedron solid polygon face face foreach polygon face foreach solid face face polygonsintersect face face return true return false go selecting potentially colliding polygon b rather testing drop bsp tree eliminating collision test much time done end performing relatively polygonpolygon intersection test implementation choose smaller two potentially colliding object larger b judging radius bounding sphere reasoning behind smaller object likely fit larger partitioning plane thus reducing number polygon considered see figure facilitate testing individual polygon b bsp tree chose store center point bounding radius polygon object model controversial choice increase memory usage bounding sphere fairly pessimistic bounding volume polygon  early hit detection  thing lot faster started course still wanted make faster figured say moving toward wall collide going reasonable speed wo nt jump far wall  chance vertex object actually end inside wall illustrated figure added new test classified necessary vertex object object vertex example end interior b know collided without performing polygon intersection test though test certainly sufficient determine collision see figure faster comparing polygon eventually took test back speed detection hit two object negligible effect speed game whole one simple reason object almost never collide example suppose throw big rock friend face rock travel toward friend time little computation performed culling early collision filter come time rock close friend flinging arm desperation unsuccessfully shield rock difficult find simple dividing plane friend rock therefore many update cycle rock close friend nt hit yet rock hit friend head total klutz least managed turn face away require much plastic surgery rock bounce travel back something like opposite direction see many update cycle rock close friend hitting one hit figure  miss  cycle much expensive  hit  cycle nt matter much faster  hit  test becomes basic principle optimization failed initially think perhaps deserve rock  aha  something sped general case perform bsp test substituting bounding box shape instead true shape part b collide bounding box go full test take much computation relatively speed great majority nearmiss case occur particular game finally added simple  bounding box safety  test ran plane divide entity quickly checked see whether two object bounding box overlapped test similar obb testing discussed later paper one bounding box per object accuracy virtue presented way using bounding volume dividing plane using one must careful bitten evil spectre numerical roundoff error illustrate look bounding sphere test might initially compute bounding sphere object like longestradius  foreach vertex object vertexdistance distance vertex object origin vertexdistance longestradius longestradius vertexdistance perform computation end number somewhat close correct radius bounding sphere though usually exact even precision whatever numerical representation using error accumulate compound mathematical step perform find vertexdistance let say sake argument bounding radius compute end little bit smaller right answer see bounding sphere small bounding sphere filter test could decide collision fact little bit object poking sphere collided much worse though detect collision two object want coordinate system mean push least one transformation matrix unless using precise picky math representing matrix game programmer generally wo nt reason speed schedule time vertex transformed hell broken loose term numerical accuracy especially since matrix nt accurate begin  think operation perform compose matrix understand error end pushing vertex away center object transformation discrepancy conclusion reported bounding sphere filter hard case grow accordingly collision detector supposed work together end contradicting bad especially trying maintain kind system invariant system decided must always true server steady state object interpenetrate yet bounding sphere test cause collision ignored might find two object interpenetrating beginning object update bad still happens system deal calling emergency routine remove object world try put back arbitrary place close last position possible    want  difficult question answer case turned back beginning asked wanted answer insufficient along writing collision detection routine assumed would able plug equationsolvers really neat looking physic rather  reverse object velocity  kind bouncing started turned order maintain physical simulation system awful computational mistake happen needed accurate collision took place  otherwise object would get stuck would bounce object supposed repelling go flying outer space ten time speed light worse find exact time collision would perform binary search time domain  timestep started time found object b colliding time would backtrack time test still colliding go backward time otherwise go forward stop find earliest time b still colliding resolution find personally satisfying find collision time compare b find closest feature object feature find close enough object consider colliding pas information physic system  let rock  examine effectiveness various filter simple game situation number acquired following situation author join game server fly hovertank using drop cargo box onto landscape box hit landscape disappears deploys repair pad appearing place repair pad pivot slide ground come rest pad come rest marked sleeping mean collision detection physic routine act upset outside force hovertank turn around touch repair pad concave area dividing plane take fly away object type polygon polygon bsp cut bsp cut                            hovertank cargo box repair pad listing collision test number time sample run effective came definitive answer status collision percent case effective average amount time taken one test timing taken pentium running linux program compiled gcc ggdb definitive collision test answer average running time                                bounding sphere tiny bounding box safety u plane divide entity u bsp hard case u diagram show plane divide entity fairly ineffective yet expensive test true though appear way u originally added bounding box safety pde much effective shown though still expensive however added bounding box safety stole easily filterable collision away pde present look like end junking pde furthermore got good say bounding box safety get even faster note high percentage time system resorted using bsp hard case sense test run pessimistic measurement since landing hovertank becomes intertwined repair pad much messily positioned average player majority gameplay extrapolating performance number system would slow uncomfortably player full game decided land complex structure however believe system meet current need code collision detection algorithm optimized spent time dealing software engineering intricacy putting together modern game seems likely simple optimization could speed test several time though feel would worthwhile modify algorithm  conclusion current work future concept  use easy filter bsp tree sped system drastically beyond simple brute force approach plenty room drastic improvement bsp tree require fair amount computation construct built easily modified except special case bsp tree useful object change shape used precomputed mesh animation precompute one bsp tree per frame animation whole technique however unappealing limitation several researcher gone creating highperformance collision detection system summarize system provide comment philip hubbard describes algorithm hub us hierarchy sphere represent object appealing first spheresphere intersection cheap hubbard engages expensive precomputation find good fit sphere given object make algorithm le attractive simulating nonrigid body also many sphere required represent complex object reasonable accuracy memory required store said sphere becomes large finally seem algorithm perform well object tightly intertwined  though result presented hubbard paper hard interpret unclear best pon lin describe method detecting collision tracking closest set feature potentially colliding object method appealing might scale well isolate feature object candidate collision navigate object rotate incrementally consider new feature even need transform object geometry test collision common case method generally involve building voronoi diagram shape question  expensive procedure limit u rigid body troublesome numerical accuracy notorious problem construction voronoi diagram recently got et al propose using hierarchy oriented bounding box obbs testing intersection box using quick test based separating axis theorem another way saying always exists separating plane two convex polyhedron basic idea bear similarity hubbard though method approximating shape testing intersection completely different obbtrees generally fit shape better hubbard sphere given number subdivision require much memory sphereapproximation system could use deeper tree within budget performance figure gottschalk et al present impressive though example present paper include nonrigid object neglect show performance number recomputation obbtrees  go  speaking seems likely next major revision engine abandon bsp tree instead use hierarchy bounding volume rather require bounding volume fit shape closely gottschalk hubbard probably use looserfitting volume correspondingly shallower tree bounding volume would contain list feature encloses determined set leafnode volume two object intersect would perform n collision detection pair offending volume though point n would small sphere axis aligned bounding box appealing candidate volume since necessitate successive matrix operation required obbs hierarchy bounding volume could made work quite well dynamic shape moving feature allowed stretch bounding volume contains stretching propagates root hierarchy moving shape always valid bounding hierarchy quickly computable continued validity would assured long never allow bounding volume shrink past original dimension bounding hierarchy moving object might slowly degrade time subtrees bounding hierarchy could incrementally recomputed maintain tight fit little computational cost hierarchy store shape feature also natural fit need since data structure would equally useful determining collision finding closest feature set fact procedute test two object collision might return set closest feature incidental sideeffect would nice compared current closestfeature routine slow  reference  chin norman chin  walk bsp tree  graphic gem v associated press fv j foley van dam feiner j hughes computer graphic principle practice nd ed addisonwesley system programming series see especially section  got gottschalk lin manocha  obbtree hierarchical structure rapid interference detection siggraph  hub philip hubbard  approximating polyhedron sphere timecritical collision detection  acm transaction graphic vol july available http siestacswustledupmhresearchhtml lin ming c lin dinesh manocha  efficient contact determination geometric model  available http wwwcsuncedumanochacollisionhtml j orourke  computational geometry c  cambridge university press isbn  paperback isbn  hardback pon madhav k ponamgi dinesh manocha ming c lin  incremental algorithm collision detection solid model  available http wwwcsuncedumanochacollisionhtml rab rich rabbitz  fast collision detection moving convex polyhedron  graphic gem iv ap professional wade bretton wade  bsp tree frequently asked question  available http rtfmmitedupubusenetnewsanswersgraphicsbsptreefaq nonauthoritative copy 