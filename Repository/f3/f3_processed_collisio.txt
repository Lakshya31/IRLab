date mon jun   tom moertel thor teleramalmcom subject collision detection date mon jul   subject typo fixed k k expansion many people requested copy collision detection code suspect general interest reader newsgroup posting code along discussion technique us please accept apology length posting code written c macintosh endeavored keep collision detection code close ansi c porting minute affair testingtiming harness c macintoshspecific take say hour longer port feel inclined overview code work roughly speaking screen divided  sector  defined regularlyspaced grid object eg sprite placed appropriate sector determined object upperleft corner object sector tested collision one another taking advantage observation overlapping object usually classified sector nt always case however code therefore make wellbehaved translation grid ensure collision detected false collision reported note first thing get code look declaration  obj  structure represents onscreen object convenience sake made object x way define x data member upperleft corner object bounding rectangle need lowerright calculate adding x way shootemup class object would different size associated eg bullet add say instead smaller keep object linked list objlink member link object sectorlink especially important used keep object sector single linked list key making collision detection technique work quickly placing object containing sector take time low constant boot mind overview implementation iterate four time shifting sector grid iteration place object appropriate sector sector check collision among object may find interesting chosen repeat entire sectorization persector collision checking process four time get around problem associated overlapping object placed adjacent sector instead testing collision object adjacent sector shift entire sector grid repeat process accuse insane  fourshifts  business know asymptotically time faster testing adjacent sector time faster common  real world  case interested analysis near end note uninterested reader may feel free skip side effect multiple iteration collision sometimes reported example two object directly top placed sector detected collided regardless sector grid shifted result particular collision reported four time nt big concern trivial way sidestep issue think remiss nt point hate people screaming particular bullet packing four time expected wallop hurling innocent spaceship oblivion analysis fourshifts v adjacentsectors begin thinking shiftandrepeat technique terribly inefficient consider alternative checking adjacent sector let say got sector middle screen call object could collide object adjacent sector include eight collision testing affect running time assume object randomly distributed screen average k object sector recall test collision sector use bruteforce technique requires n n  rectangle intersection operation check n object compare fourshifts method testadjacentsectors method fourshifts method sector checked cost k k  rectangle test process repeated time consequently cost entirely check sector k k  k k k k adjacentsectors method sector checked eight neighboring sector included check define l  k average number object sector cost per sector l l  k k   k k  let calculate ratio two method expected number rectangle test cost adjacentsectors k k  r                    cost fourshifts k k note limit r k infinity  asymptotically fourshifts method time faster adjacentsectors method admittedly unlikely infinite number object screen fact begs question much faster fourshifts method common case average one two three object sector answer one object much faster two x faster three x faster fourshifts method need perform test single object sector  common case adjacentsectors method hand need average test handle situation code enjoy let know work platform port testingtiming harness please send timing result code broken section order front matter introductory comment declaration defines constant parameter test code testingtiming harness mac specific sector code code put object sector helper function used intersection code intersection code us sector helper code determine object intersection hence collision  begin  sectorbased collision detection routine  timing code   tom moertel jun   result mhz macintosh  exactly screamer mhz ppc  power macintosh one scream   test  object count k ppc         test  defined complete  check object determining  object whether involved collision  object   note   job made object x  code work arbitrarilysized  object restriction object  smaller half ksectorsize   code far optimized didnt  even bother run profiler  little work could probably  twice fast   legal stuff   feel free use code  project please give credit   copyright tom moertel  moertel acmorg   porting    real  code portable c  testing code us mac  specific call namely microsecond  graphic windowing call  port timing code platform  redifine clockus return current  state count fast internal clock  microsecond macintosh drawing  code automaticaly compile  nonmac platform want pretty  picture roll include iostreamh include stringh include stdlibh include mathh defined macintosh  defined mwerks include typesh include quickdrawh include windowsh include eventsh include timerh endif  define compilation parameter defined mwerks  defined sc define braindeadinlining  define declare  hot  endif  function macro instead  c inline function  define test parameter enum kmaxobjects  likely need krectsize  object x pixel ktbase l  timing microsecond ktestlength ktbase  second per experiment kcyclelength  inner timing loop cycle time  type defined powerc  defined powerc typedef int scalar  fast integer type else typedef short scalar  fast integer type endif  sprite object struct obj scalar x  coords obj sectorlink  link sector list obj objlink  link obj list   member   modulescope globals static obj gobjects kmaxobjects static boolean gcollisionarray kmaxobjects  forward declatations static void determinecollisions static void showlastiteration scalar numobj static void randomizeobjects scalar numobj static void runexperiment scalar numobj boolean drawqfalse   test code   return long representing count internal clock  tick  defined powerc  defined powerc inline long clockus return tickcount ktbase else long clockus static unsignedwide base static boolean initq true initq microsecond base initq false unsignedwide x microsecond x return xlo baselo endif void main srand unsigned int clockus cout  collision testing   endl runexperiment false runexperiment false runexperiment false runexperiment true  draw one static void runexperiment scalar numobjects boolean drawq numobjects kmaxobjects return  many cout int numobjects  object  long endtime clockus ktestlength long iteration clockus endtime  nt count initialization time long clockus randomizeobjects numobjects endtime  clockus  testtiming loop scalar kcyclelength clockus endtime determinecollisions iteration long totaltime ktestlength clockus endtime drawq showlastiteration numobjects  draw result cout int iteration   int totaltime  u  float usec totaltime float iter iteration coutprecision cout useciter  usiter  float ktbase iterusec  iters  endl   sector code  define ceilingdiv x x   define constant   note work properly ksectorsize must greater  twice length largest side  object bounding box eg object  x sector size  would  excellent choice enum ksectorsize  length sector side pixel klogsectorsize  log ksectorsize shifting kscreenwidth kscreenheight knumxsectors ceilingdiv kscreenwidth ksectorsize knumysectors ceilingdiv kscreenheight ksectorsize knumsectors knumxsectors knumysectors  define modulescope array linked list head  one sector static obj gsectorarray knumxsectors knumysectors  call routine place object  appropriate sector   assumes object kept linked list  getmyfirstobject return head list extern obj getmyfirstobject static void updatesectors register scalar xoff register scalar yoff  reset sector linked list obj thearray obj gsectorarray  access scalar knumsectors thearray null  put object sector linked list obj getmyfirstobject null objlink  get list head sector resides register obj thissectorlisthead gsectorarray x xoff klogsectorsize yoff klogsectorsize  add sector linked list sectorlink thissectorlisthead thissectorlisthead   helper   draw object rectangle object involved  collision drawn rectanglular outline  otherwise drawn solid gray rectangle  macintosh specific static void drawobject obj boolean collidedq defined macintosh  defined mwerks static pattern myblack xff xff xff xff xff xff xff xff static pattern mygray xaa x xaa x xaa x xaa x rect r setrect r x x krectsize krectsize penpat collidedq myblack mygray collidedq framerect r else paintrect r endif  macintosh  conciliate skeptic showing  code indeed work properly  macintosh specific static void showlastiteration scalar numobjects defined macintosh  defined mwerks rect rbounds kscreenheight kscreenwidth offsetrect rbounds getmbarheight windowptr wind newwindow nil rbounds  p  true plaindbox windowptr  false grafptr saveport getport saveport setport wind scalar numobjects drawobject gobjects gcollisionarray button setport saveport disposewindow wind endif  macintosh static scalar randscalar scalar max return unsigned long max unsigned short rand randmax static void randomizeobjects scalar numobjects obj gobjects scalar numobjects x randscalar kscreenwidth randscalar kscreenheight objlink  objlink null   intersection code  obj getmyfirstobject return gobjects  local helper static void clearcollisionarray static void updatecollisionarray  determine collision static void determinecollisions clearcollisionarray  erase slate collision yet scalar shift ksectorsize  need try four differnt  shift   sector grid detect collision proof  left excercise  reader hint consider analogous case updatesectors updatecollisionarray updatesectors shift updatecollisionarray updatesectors shift updatecollisionarray updatesectors shift shift updatecollisionarray   hot  function used inner loop ifdef braindeadinlining define ab define intersectq ab x x krectsize ab krectsize else inline scalar ab scalar return inline scalar intersectq obj obj return ab x x krectsize ab krectsize endif  braindeadinlining static void clearcollisionarray memset gcollisionarray sizeof gcollisionarray static void calccollisionsinsector obj objlist static void updatecollisionarray scalar x x knumxsectors x scalar knumysectors calccollisionsinsector gsectorarray x  got head linked list  sector let see object  involved collision   use plain old n technique compute  collision sector grid size  appropriately chosen n small  many case obviating  collision test altogether static void calccollisionsinsector obj objlist objlist  null  objlist sectorlink  null return obj objlist sectorlink sectorlink obj ox sectorlink ox ox ox sectorlink intersectq ox gcollisionarray gobjects gcollisionarray ox gobjects  note point know object  collided object ox could use  information say determine kind  explosion appropriate however  toss information away  end regard tom moertel interest software engineering symbolic mathematics msa csg technology division algorithm thor teleramalmcom itchyscratchy theory 