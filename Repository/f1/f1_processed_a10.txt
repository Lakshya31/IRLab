chapter relocation linkage allows produce either com file run immediately standalone program obj file fed msdos link program chapter discus obj mode obj production made easy start giving minimum amount information need know produce obj file writing short interface routine want concern esoterica obj file segment group public etc survive quite nicely reading section two way cause produce obj file object output one way explicitly give obj output file name example assemble source file foo giving command  foo fooobj  way specify switch letter digit illustrated invocation  foo  effect first invocation design philosophy obj production accommodate two type user first type user writing new code link usually high level language module person able write module minimum red tape right thing second type user existing module written intelibm assembler want port recognize act upon relocation directive segment group public extrn name end given assembly work even several file assembled separately intelibm assembler fed single assembly see read entire chapter multiplefiles requirement cause interpret relocation directive little differently achieving compatible result let suppose writing new code example interface routine  c  language multiplies bit number  c  push input number onto stack calling routine code need get number multiply return answer ax register code mul  c  expects public name start   push bp  c  expects bp preserved mov bp sp use bp address stack mov ax bp fetch number n beyond bp ret addr add ax ax n mov bx ax n saved bx add ax ax n add ax ax n add ax bx n n n pop bp bp restored ret go back caller  line entire source file name file mul create object file mulobj conforms standard small model computation high level language use retf instead ret thus way getting operand bp instead bp object module conform standard large model computation red tape information required high level language provided implicitly go information detail later need read curious happens need access symbol outside module assembling type symbol correctly guessed instruction refers simply refer leave undefined within module example see instruction call print print undefined assume print near procedure print never defined within module act declared print via directive extrn print near address print plugged instruction link combine obj file high level language obj file make final program general undefined operand call jmp instruction assumed near second source operand mov arithmetic instruction assumed ab ie immediate constant undefined first destination operand assumed simple memory variable size byte word register given second operand external symbol comply guideline need declare extrn use also use extrn declare type noncomplying forward reference within module see later like link mul procedure turbo pascal v later need append line code segment public top program name program segment according turbo pascal expectation may dispense leading underscore name mul  turbo pascal require expect point casual user think read enough get going read wish get stuck need master esoterica  overview relocation linkage assemble program directly com file program two form source program understand com file computer  understand  ie execute obj file intermediate format neither executing computer make sense obj file program like link interpret obj file purpose obj file allow assemble compile part program part also form obj file produced different time often different assembler compiler whose source file different language easy see word  linkage  come link program put piece program together  relocation  come assembler compiler make given program piece nt know many piece come big piece piece constructed started location within program link  relocates  piece true location many relocation feature assembly language couched term link point view must look way link see thing link call obj file  object module   module  module name referred link issue diagnostic message error message symbol map program symbol used within single module need given link except possibly pas along symbolic debugger hand program symbol defined one module referenced module link need know name symbol resolve reference symbol public module defined  external  module containing reference finally exactly one module program must contain starting location program module called  main module  must supply starting address necessarily beginning module family microprocessor link system also much manage memory segment program fit get data grotesquely ornate level support segmentation dictated intel specified ibm compiler maker accepted format obj file attended fateful meeting intel crucial design decision made regret say sat quietly engineer senior applied fertile imagination construct fanciful scenario felt supported link let review resulting segmentation model  part program viewed link come three different size piece single segment entire single segment sequence consecutive segment memory size called something like fragment instead called segment size called segment instead called group size called  group  instead called  class  let cling sensible terminology one paragraph describe worst scenario intel wanted support discus individual directive ill regretfully revert official terminology scenario follows suppose program occupies k byte memory program contains core k byte utility routine every part program call like every part program able call routine using near form save memory gum simply slice program three fragment utility routine go fragment u rest program split equalsized kbyte fragment b arrange fragment memory order u b fragment u form kbyte block addressed segment register value g point beginning fragment u b form another kbyte block addressed segment register value g point beginning u set c register g executing g b executing u fragment accessible time since direct jmps call encoded relative offset ucode execute direct jump correctly whether addressed g huge offset g small offset course u contains absolute pointer referring indirect near jmp call trouble decade since fateful design meeting took place report scenario never taken place real world state authority never reason program exceed k byte size coded high level language assembly language high level language compiler follow restricted segmentation model  existing model come remotely close supporting scheme suggested scenario assembly language support  directive  g group u   g group b u  followed chunk code appropriate object size headed directive  segment   b segment   u segment  link program supposed sort thing according scenario ca nt say doubt actually succeeds concept  class  added afterthought implement sensible usable feature outsider thought group implementing namely ability specify different disjoint segment occur consecutively memory allows program arranged consistent manner  example program code followed static data segment followed dynamically allocated memory  name directive syntax name modulename name directive specifies  modulename  given link name module produced assembly symbol  modulename  used elsewhere program without conflict even like builtin assembler mnemonic eg  name mov  acceptable provide name directive use name output object file without obj extension provide one name directive use last one given error reported public directive syntax public sym sym sym  public public directive allows explicitly list symbol defined assembly used module give public directive program use every relocatable label variable name program except local label redefinable label consisting letter followed digit l q etc symbol equated constant symbol defined within structure data segment implicitly declared public explicitly include public directive maintains internal flag telling whether figure symbol public let program explicitly declare flag start  implicit  set  explicit  see public directive name public directive containing least one name would implicitly made public writing new code probably want keep flag  implicit  use public directive symbol form local label nt eg memory variable income absolute value globally accessed  eg specify  public openfileslimit  symbol defined  openfileslimit equ  porting existing code code already public directive go  explicit  mode duplicating functionality assembler public directive name used force  explicit  mode thus causing public name obj file declare symbol public  another side effect public directive symbol declared public module better defined module nt includes err listing undefined symbol module suppresses output object file extrn directive syntax extrn sym type sym type   type  one byte word dword qword tbyte far synonymously b w q f near ab extrn directive allows attach type symbol may yet defined may never defined within program often necessary assembler generate correct instruction form symbol used operand possible type except ab defined elsewhere language list convenience b byte bytesized memory variable w word word byte sized memory variable dword doubleword byte sized memory variable q qword quadword byte sized memory variable tword bytesized memory variable near program label accessed within segment far program label accessed outside segment ab absolute number ie immediate constant example extrn usage follows suppose word memory variable ifark program variable might declared end program might defined module completely outside program without extrn directive assemble instruction  mov ax ifark  loading immediate constant ifark ax register place directive  extrn ifark w  top program get correct instruction form mov ax ifark  moving word memory variable ax register allow one extrn directive given symbol long type given every time even allow extrn directive symbol already defined long type declared consistent symbol definition allowance exist assemble multiple file written another assembler fed separately assembler  note extrn viewed quite differently assembler fact nt assembler use mnemonic declare instead extrn doesnt really use extrn determine symbol external  us symbol undefined end assembly stated earlier chapter undefined symbol referenced without declared via extrn conversely defined symbol declared redeclared via extrn defined symbol specified  external  obj file extrn useful forward reference situation recognized even assembling com file accustomed traditional use extrn like external record created  behind back  offer  x  option include  x  program invocation require undefined symbol explicitly declared via extrn undefined undeclared symbol included err listing undefined symbol object file output suppressed main starting location program already stated exactly one module program  main  module containing starting address entire program assembling obj file starting address given label main simply provide label  main  want program start module containing main main module end directive syntax end end startaddr end directive used assembler two purpose little silly first purpose signal end assembly necessary back day source file input medium paper tape tell assembler explicitly content tape ended today operating system tell youve reached end file function anachronism second purpose end nonsensically allow specify starting location program suppose person wrote first assembler back short memory implement separate start directive main label like decided let end double duty always considered example  end start  aliceinwonderland quality fuel highlevellanguage snob like attack assembly language please defeat snob use  main  writing new code  compatibility treat  end startaddr  exactly coded  main equ startaddr  note want program assemble assembler specify  end main   treat main equ main legal redefinition symbol main ignores end startingaddress operand thus allowing assembly multiple file written assembler segment directive syntax segname segment align combine classname  align  one byte word para page  combine  one public stack common memory number segment directive say assembled object code henceforth go block code whose name  segname   segname  symbol represents value loaded segment register  segname  declared group directive value fact loaded segment register order address code  segname  declared group directive code part segment addressed name group program consist number named segment combined numerous exotic way produce final program redirect object output one segment another assembly providing segment directive piece code even return segment started earlier repeating segment name  assembler pick left subject possible skipping memory alignment describe shortly specification following word segment help describe code module part segment combined code segment name given module also named segment grouped named segment assembler require specification given order indicated accept order accept comma specification want provide restriction  number  must followed comma last specification line   align  specification tell piece code within segment aligned starting address even multiple number byte alignment mean requirement word alignment requires piece start multiple para alignment multiple page alignment multiple example suppose segment containing memory variable declare segment statement  vardata segment word  insures segment aligned even memory address way insure bit bigger memory quantity segment aligned even address faster access bit machine family special rule governing alignment multiple piece named segment within program module assembler outlaw conflicting alignment specification situation accepts us strictest specification given furthermore alignment given specification beyond first control alignment piece code within module chunk example program contains two piece code headed  vardata segment word  insert byte piece first piece odd number byte insures correct assembly multiple file written another assembler  align  type given piece named segment alignment para assumed  combine  specification tell chunk code module combined chunk named segment come module yes know sound like  align   combine  take different major point view public kind combination talking along piece segment located end previously linked piece subject possible gap alignment size segment sum size piece plus size gap stack combination type reserved system stack segment illustrate stack segment chunk combined let describe way stack segment ever used call segment stack declare follows stack segment word stack dw dup topofstack  code given declares stack area byte word module identical code occurs three module linked together resulting stack segment byte size added topofstack address module piece overlayed top segment way every module declare access top stack static part stack code ever refer common type memory area supported fortran module chunk common segment start location overlap usually duplicate piece module size common segment size largest chunk memory supposed another kind common segment distinguished automatically located beyond segment memory msdos link program however implement memory segment instead treat identically public common segment see useful purpose memory combine type since functionality achieved putting common segment class go class nt use memory sorry nt support assembly multiple file written assembler contain stack common memory segment would detect file break duplicate overlapping functionality segment type since nt think anybody using esoteric type nt bother support extent objection anyone  number  defines noncombinable segment absolute memory location whose segment register value  number  form useful initializing data fixed location interrupt vector ivector segment followed org intnumber reading fixed memory location bios variable area biosdata segment combine type specification repeated subsequent piece given segment must piece finally combine type ever given named segment module segment noncombinable  module may define segment code given one module constitutes entire segment  last specification available segment line class name identified enclosed single quote unlike segment name used instruction operand hence conflict assembler symbol class name assigned without regard usage elsewhere program even builtin mnemonic fact small large highlevellanguage model specify class name code code segment small model specifies class name data class name given segment specifies null zero length string class name data segment struc code segment directive data segment struc directive work obj mode exactly com mode  define special assembly mode declaration made object code output offset within data segment structure absolute com mode assembly resume end code segment directive encountered masm compatibility especially module written link turbo pascal v program recognize keywords code data stack ordinary relocatable segment name ordinary functionality take effect whenever segment directive given code data stack segment name one relocatable parameter eg public given segment end directive syntax segname end end directive close segment currently assembled return assembly segment assembled last segment directive  segname  given must match name last segment directive end allows  nest  segment inside one another example declare static data variable specific certain section code top section data segment byte public data var db var db data end four line inserted inside segment assembled cause two variable allocation tacked onto segment data assembly continue whatever segment surrounded four line observe  nesting  occur final program presentation source code nested  nesting segment inside one another end directive serf lend clean  blockstructured  appearance source code assist particular way fact consumes bit object output memory slightly reducing object output capacity end rather starting new segment segment directive default outer segment assembler outlaw code outside segment declaration forcing give segment declaration assemble anything let assemble code nt worry segment nt want provide code outside segment declaration performs following step find reasonable place put code segment explicitly declared whose name end  text  first segment declared used segment declaration appeared top rather within program explicit segment creates byte public segment class code proceeds construct name segment retf instruction outer segment name chosen  text  conforming small model computation retf instruction name chosen  modulenametext   modulename  name module recall  modulename  come name directive one name obj file nt group directive syntax groupname group segname segname  group directive cause tell link listed segment fit single kbyte block memory instruct link make fit wo nt fit link issue error message declared group use  groupname  segment register value allow simultaneous access named segment order name given list necessarily determine order segment finally appear within group useful application group directive allow structure piece program whose code data fit single k segment organize piece segment declare segment within group program start segment register set point group never worry segment register program  warning segment grouped final program appropriate group directive every module assembled nt memory pointer generated relative beginning individual named segment beginning whole group obscure scenario described overview section intel prohibit one group containing segment neither pointer within segment calculated beginning last group segment declared within doubt whether link handle correctly seg operator syntax seg operand seg operator return segment containing operand  value suitable loading one segment register operand explicit far constant  value returned lefthand component constant example otherwise result depends output mode assembling obj file result named relocatable segment containing operand seg useful operand defined module case segment value plugged link assembling com file seg always return c register one exception symbol declared within segment structure return value containing segment com file facility explicitly specifying relocatable segment compatibility assumes nonabsolute segment reference program segment 