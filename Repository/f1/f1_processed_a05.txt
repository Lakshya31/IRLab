chapter exclusive feature statement  nudge  direction structured programming offer statement suppose want conditionally skip around one instruction ordinarily would require example jnz l skip following move nz mov ax bx make move z l label exists skip may replace code single line z mov ax bx line generates exactly code previous line  conditional jump opposite condition around statement given tail statement statement macro call giving opportunity skip something complicated may use condition would follow  j  conditional jump instruction except cxz reverse condition assembler interprets condition appending  j  beginning condition symbol  c   nc   z   nz  etc reserved assembler defined context multiple operand push pop inc dec accept number register operand instruction push pop inc dec generate appropriate machine instruction operand example statement push ax bx two statement push ax push bx numeric operand appearing inc dec statement cause previous inc dec propagated number time example statement inc ax generate inc ax instruction statement dec al bx generate dec al dec bx dec al dec bx sorry numeric operand allowed operand affected forward reference relocatable quantity eg inc foo foo undefined case want code efficient add foo anyway  conditional return instruction programmer accustomed conditional return instruction z appreciate following feature allows operand conditional jump instruction one three ret instruction ret retf iret assembler find nearby return instruction indicated flavor use target conditional jump example jz ret replacement rz returnifzero instruction assembly language find nearby instruction attach label use label note suffice attach label single ret instruction use label throughout program range conditional jump byte either direction happens find nearby return instruction case issue error  jump  next matching return instruction program subsequent return instruction return mnemonic appear undefined symbol end program either case correct problem inserting freestanding return instruction nearby point program affect existing code typically following unconditional jmp instruction good place insert return instruction always replace  jcond ret   cond ret  extension mov xchg instruction number mov xchg instruction available part machine instruction set first move segment register immediate constant segment register allowed example code mov e d assembler generate push d followed pop e effect move intended code mov d assembler generate push ax mov ax mov d ax pop ax mainly convenience user load segment register manually second mov allows operand statement mov x z equivalent two statement mov z followed mov x sorry segment override allowed conjunction operand movs override preceding mov ambiguous meaning override within operand handled correctly code two mov instruction want either segment override third accepts mov wordsized memory operand another wordsized memory operand handle way handle mov segment register generates push source followed pop destination  finally allows xchg segment register except c wordsized quantity well xchg two wordsized memory quantity machine instruction available xchg b generates push followed mov b followed pop b local symbol examine assembly language program symbol table find symbol partitioned two level significance half symbol name procedure variable global significance name symbol chosen intelligently carefully program readability improves drastically usually nt chosen well often assembler restricts symbol letter programmer habit influenced assembler half symbol program much lower local significance place marker used implement small loop local branching eg  skip next instruction zflag set  assigning fullblown name symbol reduces readability program two way first harder recognize local jump  usually assembly language equivalent high level language construct like statement loop second harder follow global significant symbol buried sea place marker symbol symbol table solves problem local symbol symbol program consists single letter followed one decimal digit l x etc symbol local symbol local symbol appear xref crossreference listing also redefined something completely different later program local symbol type label memory variable etc local symbol redefined must take care specify one referring program reference forward reference label occurs program reference reference must preceded   example l movsb inc bx loop l lack   mean l statement jnz l   indicates l statement jmp l jmp l disallowed overlap range l  recommend assign local label name l l program complex need place holder one stretch code stretch need rewritten operand aam aad instruction examined family opcodes eagle eye noticed somewhat spurious   opcode generated every aam aad instruction opcode provide constant divisor multiplicand instruction believe nt enough room microcode original hold constant although intel never announced generality aam aad substitute constant decimal constant used support letting give constant bytesized operand aam aad particularly useful instruction aam unpacks al nibble ah al aad revers process packing nibble ah al al warning couple user point aad instruction general operand wo nt work nec v v chip operand assumed matter really since large number pc  speed  kit involve switching nec chip seen many pc use aad operand want program run everybody machine bad aam work fine though singleoperand form test instruction allows test instruction single operand set flag according value operand operand register generates test register operand memory quantity generates test memory constant  ie quantity anded constant example instead test dl dl code simply test dl instead test wvarffff code simply test wvar optimized lea instruction many assemblylanguage programmer habit using example lea si memloc instead equivalent mov si offset memloc load immediate value represents pointer memory location however lea instruction form generates one byte object code mov form recognizes situation generates moreefficient mov instruction also applies register move mov ax bx instead lea ax bx  gotten little flak user feature claim violates policy  behind back  action feel feature completely equivalent code optimization situation short jmp form instead equivalent near jmp byte operand add si instead word operand onebyte xchg ax bx instead general xchg rw ew form etc etc etc situation absolute functional equivalence form try generate efficient form convinced offer l switch described chapter user also gotten mistaken impression reading intel confusing spec longer lea sometimes faster shorter mov never case  user reading clock count memoryfetch form mov registeronly immediatevalue form nt believe try timing consecutive lea loop executes time v similar loop equivalent mov 